import{_ as n}from"./plugin-vue_export-helper-c27b6911.js";import{r,o as t,c as o,b as e,d as a,e as c,f as s}from"./app-cda9265d.js";const d="/Lion_Blog/images/browser/解决跨域_Jsonp.jpg",l="/Lion_Blog/images/browser/解决跨域_前端Proxy.jpg",h={},p=e("h2",{id:"原理",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#原理","aria-hidden":"true"},"#"),a(" 原理")],-1),_=e("p",null,"浏览器的同源策略：协议、域名、端口号",-1),g={href:"http://manage.adlt.clashpig.cn/",target:"_blank",rel:"noopener noreferrer"},f=s('<ul><li>manage - 服务器</li><li>adlt - 域</li><li>clashpig - 机构</li><li>cn - 国家(可省)</li></ul><h2 id="解决跨域" tabindex="-1"><a class="header-anchor" href="#解决跨域" aria-hidden="true">#</a> 解决跨域</h2><div class="hint-container warning"><p class="hint-container-title">Get请求没有跨域问题？</p><ul><li>通过 HTML 的<code>静态资源加载机制实现</code>的，不会涉及 AJAX 请求，所以<code>不会触发跨域问题</code>。</li><li>通过XMLHttpRequest 或 Fetch API 发起的 <code>AJAX</code> 请求，叠加同源策略中不同源的场景就<code>会触发跨域</code>问题了</li></ul></div><h3 id="jsonp" tabindex="-1"><a class="header-anchor" href="#jsonp" aria-hidden="true">#</a> JSONP</h3><figure><img src="'+d+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>原理: script不受限制 仅get请求</p><p>话术: 动态生成script标签，请求网址，将回调函数名作为参数附带在请求中，服务器接收到请求后，将收到的函数名和客户端需要的数据拼接成字符串返回，客户端声明回调函数，回调函数的参数就是所需数据。</p><h3 id="cors" tabindex="-1"><a class="header-anchor" href="#cors" aria-hidden="true">#</a> CORS</h3><p>CORS是基于http1.1的一种跨域解决方案</p><p>HTTP1.1 Access-Control-Allow-Origin:*</p><h3 id="nginx反向代理-后台" tabindex="-1"><a class="header-anchor" href="#nginx反向代理-后台" aria-hidden="true">#</a> Nginx反向代理（后台）</h3><h3 id="proxy代理-前端开发环境" tabindex="-1"><a class="header-anchor" href="#proxy代理-前端开发环境" aria-hidden="true">#</a> Proxy代理（前端开发环境）</h3><figure><img src="'+l+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>',13);function u(x,m){const i=r("ExternalLinkIcon");return t(),o("div",null,[p,_,e("p",null,[e("a",g,[a("http://manage.adlt.clashpig.cn/"),c(i)])]),f])}const y=n(h,[["render",u],["__file","浏览器跨域.html.vue"]]);export{y as default};
