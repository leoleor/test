import{_ as o}from"./plugin-vue_export-helper-c27b6911.js";import{r as t,o as i,c as l,b as e,d as s,e as n,f as a}from"./app-cda9265d.js";const p={},c=a(`<h2 id="前言" tabindex="-1"><a class="header-anchor" href="#前言" aria-hidden="true">#</a> 前言</h2><p>传统的网页根据用户访问的不同的地址，浏览器从服务器获取对应页面的内容展示给用户。这样造成服务器压力比较大，而且用户访问速度也比较慢。</p><h2 id="前端路由" tabindex="-1"><a class="header-anchor" href="#前端路由" aria-hidden="true">#</a> 前端路由</h2><p>hash模式就是通过监听浏览器的hash值(锚点)来实现前端渲染；<br> history模式是通过操作浏览器的历史记录并监听这个动作来实现前端渲染。浏览器每访问一个地址，都会在浏览器栈里存入路径记录。</p><h3 id="模式" tabindex="-1"><a class="header-anchor" href="#模式" aria-hidden="true">#</a> 模式</h3><ul><li>hash模式：location.hash+hashchange</li></ul><p>location.hash始终指向页面url中#之后的内容，用来修改浏览器的地址；<br> hashchange来监听变化做出相应渲染 ​</p><ul><li>history模式：html5推出的historyAPI</li></ul><p>window.history.go、window.history.forward、window.history.back、window.history.pushState、window.history.replaceState，主要通过pushState和replaceState实现；popstate来监听变化</p><h3 id="区别" tabindex="-1"><a class="header-anchor" href="#区别" aria-hidden="true">#</a> 区别</h3><ul><li>外观</li></ul><p>hash带#</p><ul><li>兼容性</li></ul><p>history利用的是html5推出的historyAPI，兼容性差</p><ul><li>是否需要后端配合</li></ul><p>hash模式只由前端控制；history模式需要我们与后端人员进行紧密配合，如果前端发起请求的URL与后端的URL不一致的话，会报404错误。</p><ul><li>实现原理</li></ul><p>hash模式，其原理就是监听（浏览器暴露的hashchange方法）url中hash(锚点)的变化；<br> history的原理就是利用html5推出的history身上的API</p><h2 id="router" tabindex="-1"><a class="header-anchor" href="#router" aria-hidden="true">#</a> $router</h2><h3 id="概念" tabindex="-1"><a class="header-anchor" href="#概念" aria-hidden="true">#</a> 概念</h3><p>指的是router实例<br> router是路由实例对象，包含一些路由跳转方法，比如push。</p><h3 id="属性" tabindex="-1"><a class="header-anchor" href="#属性" aria-hidden="true">#</a> 属性</h3><ul><li><code>$router.app</code>：配置了router的Vue根实例</li><li>​<code>$router.mode</code>：路由模式，这里是hash</li><li><code>$router.currentRoute</code>：当前路由的路由信息对象，包含了当前匹配路由的信息</li></ul><h3 id="方法" tabindex="-1"><a class="header-anchor" href="#方法" aria-hidden="true">#</a> 方法</h3><ul><li><code>router.addRoutes(routes)</code>：动态添加路由规则，参数为符合routes选项要求的数组</li><li><code>router.beforeEach((to,from,next) =&gt; {})</code>：全局前置守卫</li><li><code>router.beforeResolve((to,from,next) =&gt; {})</code>：全局解析守卫, 在导航被确认之前，且在锁头组件内守卫和异步路由组件被解析之后调用</li><li><code>router.afterEach((to,from) =&gt; {})</code>：全局后置守卫</li><li><code>router.go(n)</code>：接受一个整数作为参数，类似window.history.go(n)，在浏览器历史记录中前进或后退几步</li><li><code>router.push(location)</code>：跳转导航的方法，这种方法会向history栈添加一个新的记录，编程式导航：</li></ul><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// ​query要用path来引入，params要用name来引入</span>
​<span class="token keyword">this</span><span class="token punctuation">.</span>$router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token string">&#39;/path&#39;</span><span class="token punctuation">,</span> <span class="token literal-property property">query</span><span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">&#39;狮子&#39;</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
​<span class="token keyword">this</span><span class="token punctuation">.</span>$router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">&#39;name&#39;</span><span class="token punctuation">,</span> <span class="token literal-property property">parmas</span><span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">&#39;狮子&#39;</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>router.replace(location)</code>：和router.push()类似，但是它会替换掉当前的history记录，不会添加新的记录</li><li><code>router.back()</code>：相当于router.go(-1)</li><li>​<code>router.forward()</code>：相当于router.go(1)</li></ul><h2 id="route" tabindex="-1"><a class="header-anchor" href="#route" aria-hidden="true">#</a> $route</h2><h3 id="概念-1" tabindex="-1"><a class="header-anchor" href="#概念-1" aria-hidden="true">#</a> 概念</h3><p>是当前激活的路由信息对象，是只读属性，不可更改，但是可以watch，$route(to,from)<br> route是路由信息对象，包含和路由相关的一些信息，比如params,location等。</p><h3 id="属性-1" tabindex="-1"><a class="header-anchor" href="#属性-1" aria-hidden="true">#</a> 属性</h3><ul><li><code>$route.fullPath</code>：完成解析后的url，包含查询参数和hash的完整路径</li><li><code>$route.path</code>：路径，字符串类型，解析为绝对路径</li><li><code>$route.hash</code>：当前路由的hash值（带#号的），如果没有hash值则为空字符串</li><li><code>$router.name</code>：当前路由的名称，如果有的话（用于命名路由）</li><li><code>$route.params</code>：一个键值对对象，路由参数</li><li><code>$route.query</code>：一个键值对对象，表示url查询参数</li><li><code>$route.matched</code>：一个包含了当前路由的所有嵌套路径片段的路由记录（routes配置数组中的对象副本）</li><li><code>$route.redirectedFrom</code>：重定向来源的路由的名字，如果存在重定向的话</li></ul><h2 id="路由钩子" tabindex="-1"><a class="header-anchor" href="#路由钩子" aria-hidden="true">#</a> 路由钩子</h2>`,33),d={href:"https://blog.csdn.net/weixin_39907729/article/details/124386097",target:"_blank",rel:"noopener noreferrer"},h=a(`<ul><li><p>全局钩子</p><ul><li>全局前置守卫 router.beforeEach</li><li>全局解析守卫 router.beforeResolve</li><li>全局后置钩子 router.afterEach</li></ul></li><li><p>路由钩子</p><ul><li>router.beforeEnter</li></ul></li><li><p>组件钩子</p><ul><li>beforeRouterEnter</li><li>beforeRouterUpdate</li><li>beforeRouterLeave</li></ul></li></ul><h2 id="路由组件" tabindex="-1"><a class="header-anchor" href="#路由组件" aria-hidden="true">#</a> 路由组件</h2><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 路由链接</span>
<span class="token operator">&lt;</span>router<span class="token operator">-</span>link <span class="token operator">/</span><span class="token operator">&gt;</span>
<span class="token comment">// 路由占位符  </span>
<span class="token operator">&lt;</span>router<span class="token operator">-</span>view <span class="token operator">/</span><span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="路由懒加载" tabindex="-1"><a class="header-anchor" href="#路由懒加载" aria-hidden="true">#</a> 路由懒加载</h2><ul><li>Vue异步组件 <code>component: resolve =&gt; require([&#39;放入需要加载的路由地址&#39;], resolve)</code></li><li>ES6标准语法 <code>import()</code></li><li>Webpack <code>require</code>、<code>ensure()</code></li></ul><h2 id="动态路由" tabindex="-1"><a class="header-anchor" href="#动态路由" aria-hidden="true">#</a> 动态路由</h2>`,6),u={href:"https://www.jb51.net/article/224782.htm",target:"_blank",rel:"noopener noreferrer"},k=a('<h3 id="前端控制" tabindex="-1"><a class="header-anchor" href="#前端控制" aria-hidden="true">#</a> 前端控制</h3><ul><li><p>好处</p><ul><li>不用后端帮助，路由表维护在前端</li><li>逻辑相对比较简单，比较容易上手</li></ul></li><li><p>思路</p></li></ul><p>菜单管理麻烦，后端返回用户的角色，前端在路由配置里，通过meta属性，扩展权限相关的字段，在路由守卫（beforeEach）里通过判断这个权限标识，实现路由的动态增加，及页面跳转；如：我们增加一个role字段来控制角色</p><h3 id="后端控制" tabindex="-1"><a class="header-anchor" href="#后端控制" aria-hidden="true">#</a> 后端控制</h3><ul><li><p>好处</p><ul><li>相对更安全一点</li><li>路由表维护在数据库</li></ul></li><li><p>思路</p></li></ul><p>一般要有菜单管理，菜单可配置权限，角色，用户，后台根据用户的角色返回菜单列表，前端把菜单列表转换成想要的路由结构，动态渲染到页面。</p><h2 id="浏览器跳转和路由跳转" tabindex="-1"><a class="header-anchor" href="#浏览器跳转和路由跳转" aria-hidden="true">#</a> 浏览器跳转和路由跳转</h2><ul><li>vue-router使用pushState进行路由更新，静态跳转，页面不会重新加载；location.href会触发浏览器，页面重新加载一次</li><li>vue-router使用diff算法，实现按需加载，减少dom操作</li><li>vue-router是路由跳转或同一个页面跳转；location.href是不同页面间跳转；</li><li>vue-router是异步加载this.$nextTick(()=&gt;{获取url})；location.href是同步加载</li></ul>',8);function f(m,b){const r=t("ExternalLinkIcon");return i(),l("div",null,[c,e("p",null,[e("a",d,[s("进入页面触发顺序"),n(r)])]),h,e("p",null,[e("a",u,[s("文章"),n(r)])]),k])}const g=o(p,[["render",f],["__file","router.html.vue"]]);export{g as default};
