const t=JSON.parse('{"key":"v-dc67149a","path":"/accumulation/JavaScript/var%E5%92%8Clet%E5%92%8Cconst.html","title":"var和let和const","lang":"zh-CN","frontmatter":{"title":"var和let和const","category":["面试"],"tag":["JavaScript"],"star":false,"sticky":false,"article":true,"description":"定义 var定义的变量； let定义的变量； const定义的常量 作用域 var作用域是整个封闭函数，是全域的； let作用域是在块级或者字块中； const跟let一样作用于块级作用域 变量提升 不论通过var声明的变量处于当前作用于的第几行，都会提升到作用域的最顶部；var完成了声明和初始化，初始化的值为undefined；function完成声明、初始化和赋值； 只要块级作用域内存在let，它所声明的变量就会绑定在这个区域，但是let声明的变量不会在顶部初始化，解析let那一行才初始化或者初始化和赋值，凡是在let声明之前使用该变量都会报错not defined，称为暂时性死区； const没有变量提升，声明时必须初始化（赋值），重复声明会报错，声明的常量不可改变 重复声明 同一作用域内，var可以 同一作用域内，let不可以 同一作用域内，const不可以 内存分配 var会先直接在栈内存分配内存空间，等执行实际语句的时候，再存储对应变量，如果是引用类型，那么会在堆内存开辟一个空间，栈内存指针指向堆内存； let不会预分配，而且会检查，相同变量名则报错； const也不会预分配，const不可修改，但可以修改对象里的属性","head":[["meta",{"property":"og:url","content":"https://leoleor.github.io/test/accumulation/JavaScript/var%E5%92%8Clet%E5%92%8Cconst.html"}],["meta",{"property":"og:site_name","content":"一只攻城狮"}],["meta",{"property":"og:title","content":"var和let和const"}],["meta",{"property":"og:description","content":"定义 var定义的变量； let定义的变量； const定义的常量 作用域 var作用域是整个封闭函数，是全域的； let作用域是在块级或者字块中； const跟let一样作用于块级作用域 变量提升 不论通过var声明的变量处于当前作用于的第几行，都会提升到作用域的最顶部；var完成了声明和初始化，初始化的值为undefined；function完成声明、初始化和赋值； 只要块级作用域内存在let，它所声明的变量就会绑定在这个区域，但是let声明的变量不会在顶部初始化，解析let那一行才初始化或者初始化和赋值，凡是在let声明之前使用该变量都会报错not defined，称为暂时性死区； const没有变量提升，声明时必须初始化（赋值），重复声明会报错，声明的常量不可改变 重复声明 同一作用域内，var可以 同一作用域内，let不可以 同一作用域内，const不可以 内存分配 var会先直接在栈内存分配内存空间，等执行实际语句的时候，再存储对应变量，如果是引用类型，那么会在堆内存开辟一个空间，栈内存指针指向堆内存； let不会预分配，而且会检查，相同变量名则报错； const也不会预分配，const不可修改，但可以修改对象里的属性"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-02-22T09:43:27.000Z"}],["meta",{"property":"article:author","content":"狮子"}],["meta",{"property":"article:tag","content":"JavaScript"}],["meta",{"property":"article:modified_time","content":"2025-02-22T09:43:27.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"var和let和const\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-02-22T09:43:27.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"狮子\\"}]}"]]},"headers":[],"git":{"createdTime":1740217407000,"updatedTime":1740217407000,"contributors":[{"name":"狮子","email":"hzr1642921219@163.com","commits":1}]},"readingTime":{"minutes":1.36,"words":407},"filePathRelative":"accumulation/JavaScript/var和let和const.md","localizedDate":"2025年2月22日","excerpt":"<ul>\\n<li>\\n<p>定义</p>\\n<ul>\\n<li>var定义的变量；</li>\\n<li>let定义的变量；</li>\\n<li>const定义的常量</li>\\n</ul>\\n</li>\\n<li>\\n<p>作用域</p>\\n<ul>\\n<li>var作用域是整个封闭函数，是全域的；</li>\\n<li>let作用域是在块级或者字块中；</li>\\n<li>const跟let一样作用于块级作用域</li>\\n</ul>\\n</li>\\n<li>\\n<p>变量提升</p>\\n<ul>\\n<li>不论通过var声明的变量处于当前作用于的第几行，都会提升到作用域的最顶部；var完成了声明和初始化，初始化的值为undefined；function完成声明、初始化和赋值；</li>\\n<li>只要块级作用域内存在let，它所声明的变量就会绑定在这个区域，但是let声明的变量不会在顶部初始化，解析let那一行才初始化或者初始化和赋值，凡是在let声明之前使用该变量都会报错not defined，称为<code>暂时性死区</code>；</li>\\n<li>const没有变量提升，声明时必须初始化（赋值），重复声明会报错，声明的常量不可改变</li>\\n</ul>\\n</li>\\n<li>\\n<p>重复声明</p>\\n<ul>\\n<li>同一作用域内，var可以</li>\\n<li>同一作用域内，let不可以</li>\\n<li>同一作用域内，const不可以</li>\\n</ul>\\n</li>\\n<li>\\n<p>内存分配</p>\\n<ul>\\n<li>var会先直接在栈内存分配内存空间，等执行实际语句的时候，再存储对应变量，如果是引用类型，那么会在堆内存开辟一个空间，栈内存指针指向堆内存；</li>\\n<li>let不会预分配，而且会检查，相同变量名则报错；</li>\\n<li>const也不会预分配，const不可修改，但可以修改对象里的属性</li>\\n</ul>\\n</li>\\n</ul>","autoDesc":true}');export{t as data};
