import{_ as t}from"./plugin-vue_export-helper-c27b6911.js";import{o as e,c as o,f as a}from"./app-2c6ee9ee.js";const r="/test/images/javascript/原型链.jpg",i={},_=a('<h2 id="原型" tabindex="-1"><a class="header-anchor" href="#原型" aria-hidden="true">#</a> 原型</h2><p>JavaScript 中，有普通对象（new出来的）和函数对象，Object ，Function 是JS自带的函数对象。每个对象都有原型（null和undefined除外），<code>可以把它理解为存放对象的默认属性和方法的一个对象</code>。比如Object的原型就是一个Object对象，它里面存在着一些对象的方法和属性，例如最常见的toString方法。再比如说Array也是一个函数对象，它的原型就是Array.prototype，它里面存在着一些数组的方法和属性，例如常见的filter，find，map，push等方法。</p><h3 id="原型链" tabindex="-1"><a class="header-anchor" href="#原型链" aria-hidden="true">#</a> 原型链</h3><figure><img src="'+r+'" alt="图解" tabindex="0" loading="lazy"><figcaption>图解</figcaption></figure><ol><li>所有引用类型（函数，数组，对象，除了null，undefined）都拥有__proto__属性（隐式原型），所有函数除了有_proto_属性之外还拥有prototype属性（显式原型）</li><li>每创建一个构造函数大A都有一个prototype属性指向它的原型对象，（原型对象上有一个constructor属性指向它关联的构造函数）通过大A创造的实例小a有一个__proto__属性，指向它构造函数的原型对象。当想要在小a访问一个方法的时候，会先在小a里查找有没有这个方法，如果没有，就会往大A的原型对象查找，如果说，大A的原型对象又是另外一个构造函数B创建的实例，也就是大A的原型对象有一个__proto__属性指向大B的原型对象，那么小a会继续往函数B的原型对象查找，一直找到null为止，这个查找过程形成的链路就是原型链。</li><li>由相互关联的原型组成的链状结构</li></ol>',5),n=[_];function c(l,d){return e(),o("div",null,n)}const f=t(i,[["render",c],["__file","原型和原型链.html.vue"]]);export{f as default};
